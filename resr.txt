- name: Autogenerate TFT_eSPI setup (display_presets + pins_display)
  if: ${{ steps.map.outputs.tft_enabled == 'true' }}
  shell: bash
  run: |
    set -euo pipefail
    BOARD="${{ github.event.inputs.board_label }}"
    CSV_DISP="scaffold/configs/displays/display_presets.csv"
    CSV_PINS="scaffold/configs/pins/pins_display.csv"
    TE="$HOME/Arduino/libraries/TFT_eSPI"
    USD="$TE/User_Setups"
    mkdir -p "$USD"

    sed -i 's/\r$//' "$CSV_DISP" "$CSV_PINS" || true

    python3 - << 'PY'
import csv, os, sys, re

board     = os.environ["BOARD"]
csv_disp  = os.environ["CSV_DISP"]
csv_pins  = os.environ["CSV_PINS"]
usd       = os.environ["USD"]

def read_display_preset(csv_path):
    # We assume your workflow already chose a display "model" (e.g. ILI9341),
    # but to keep this self-contained we just pick the first row (or you can
    # thread in steps.disp_resolve.outputs here if you prefer).
    # If you do thread it in, match on 'model' or profile name.
    # For now we?ll take the FIRST non-comment row as the chosen model.
    with open(csv_path, newline='') as f:
        r = csv.DictReader(f)
        rows = [row for row in r]
    if not rows:
        return {"defines": "", "header": ""}
    # In your flow, steps.disp_resolve already outputs disp_define/disp_header.
    # This autogen step can run with that, but here we just grab by model name when needed.
    # To bind strictly to your ?model? selected upstream, pass it via env and filter here.
    return rows[0]

def read_pins_for_board(csv_path, board_label):
    with open(csv_path, newline='') as f:
        r = csv.DictReader(f)
        for rec in r:
            if (rec.get("board_label") or "").strip() == board_label:
                return rec
    return None

def tokens_from_defines(s):
    # allow separators: space / semicolon / comma
    s = (s or "").strip()
    if not s:
        return []
    parts = re.split(r'[;, \t]+', s)
    return [p for p in parts if p]

disp = read_display_preset(csv_disp)
pins = read_pins_for_board(csv_pins, board)
if pins is None:
    print(f"::error ::Board '{board}' not found in {csv_pins}", file=sys.stderr)
    sys.exit(1)

hdr_lines = ["// Autogenerated from display_presets.csv + pins_display.csv"]

# 1) Emit your tokens exactly (e.g. TFT_ILI9341) AND the matching *_DRIVER for TFT_eSPI
for tok in tokens_from_defines(disp.get("defines")):
    hdr_lines.append(f"#define {tok}")
    # Derive TFT_eSPI macro if looks like TFT_MODEL
    if tok.startswith("TFT_"):
        model = tok[len("TFT_"):]
        # keep alnum/underscore only
        model = re.sub(r'[^A-Za-z0-9_]', '', model)
        if model:
            hdr_lines.append(f"#define {model}_DRIVER")

# 2) Emit pin defines (TFT_eSPI naming)
def V(row, k): return (row.get(k) or "").strip()

pin_pairs = [
    ("TFT_MISO","TFT_MISO"),
    ("TFT_MOSI","TFT_MOSI"),
    ("TFT_SCK" ,"TFT_SCLK"),
    ("TFT_CS"  ,"TFT_CS"),
    ("TFT_DC"  ,"TFT_DC"),
    ("TFT_RST" ,"TFT_RST"),
    ("TFT_BL"  ,"TFT_BL"),
]
for csv_name, tft_name in pin_pairs:
    val = V(pins, csv_name)
    if val:
        hdr_lines.append(f"#define {tft_name} {val}")

# Touch: usually only CS needed (shared SPI), support optional IRQ
tc = V(pins, "TOUCH_CS")
if tc: hdr_lines.append(f"#define TOUCH_CS {tc}")
for irqcol in ("TOUCH_IRQ","TOUCH_INT","TOUCH_IRQ_PIN"):
    irq = V(pins, irqcol)
    if irq:
        hdr_lines.append(f"#define TOUCH_IRQ {irq}")
        break

out = os.path.join(usd, "User_Setup_Autogen.h")
with open(out, "w") as w:
    w.write("\n".join(hdr_lines) + "\n")

print("=== TFT_eSPI AUTOGEN SUMMARY ===")
print("Board:", board)
print("Defines:", disp.get("defines",""))
print("\n".join(hdr_lines))
PY
    CSV_DISP="$CSV_DISP" CSV_PINS="$CSV_PINS" USD="$USD" BOARD="$BOARD" python3 - << 'PY' >/dev/null 2>&1 || true

    # Point selector to the autogen setup
    cat > "$TE/User_Setup_Select.h" <<'H'
    // Auto-generated by workflow ? CSV-driven
    #include <User_Setups/User_Setup_Autogen.h>
    H

    echo "Applied TFT_eSPI autogen header."
