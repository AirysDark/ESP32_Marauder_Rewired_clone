#!/usr/bin/env python3
import json, os, sys, re, argparse

def norm_id(s: str) -> str:
    s = (s or "").strip()
    if not s:
        return ""
    # Lowercase, keep [a-z0-9_], turn spaces/dashes into underscore
    s = s.replace("-", "_").replace(" ", "_")
    s = re.sub(r"[^a-zA-Z0-9_]", "", s)
    # no leading digit
    if re.match(r"^\d", s):
        s = "_" + s
    return s

def load_modules(path: str):
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)

    # Accept shapes:
    # 1) { "modules": [ { "id": "...", "enabled": true, ...}, ...] }
    # 2) [ { "id": "...", ... }, ... ]
    # 3) { "wifi_scanner": { "enabled": true, "name": "WiFi Scanner" }, ... }  (id-keyed map)
    mods = []
    if isinstance(data, list):
        for m in data:
            if isinstance(m, dict):
                mods.append(m)
    elif isinstance(data, dict):
        if isinstance(data.get("modules"), list):
            for m in data["modules"]:
                if isinstance(m, dict):
                    mods.append(m)
        else:
            # id-keyed map
            for k, v in data.items():
                if isinstance(v, dict):
                    vv = dict(v)
                    vv.setdefault("id", k)
                    mods.append(vv)
    else:
        print("::error ::Unsupported modules_presets.json shape", file=sys.stderr)
        sys.exit(1)

    # Normalize
    out = []
    for m in mods:
        mid = norm_id(m.get("id") or m.get("name") or m.get("module") or "")
        if not mid:
            # try to synthesize from category+name
            mid = norm_id(f'{m.get("category","")}_{m.get("name","")}')
        if not mid:
            continue
        if str(m.get("enabled", True)).lower() in ("false", "0", "no"):
            continue
        out.append({"id": mid, "name": m.get("name", mid)})
    return out

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--modules-json", required=True)
    ap.add_argument("--out-cpp", required=True)
    ap.add_argument("--out-h", required=False)
    ap.add_argument("--ns", default="RegistryInit")  # class/namespace that owns init()
    args = ap.parse_args()

    mods = load_modules(args.modules_json)
    os.makedirs(os.path.dirname(args.out_cpp), exist_ok=True)
    if args.out_h:
        os.makedirs(os.path.dirname(args.out_h), exist_ok=True)

    # Header (optional): list visible to the sketch if you want
    if args.out_h:
        with open(args.out_h, "w", encoding="utf-8") as h:
            h.write("// Autogenerated: registered_modules.h\n#pragma once\n\n")
            if mods:
                h.write("/* Enabled modules (sanitized IDs): */\n")
                for m in mods:
                    h.write(f"//  - {m['id']}\n")
            else:
                h.write("// (no enabled modules discovered)\n")

    # C++ body: weak externs + guarded calls
    with open(args.out_cpp, "w", encoding="utf-8") as w:
        w.write("// Autogenerated: RegistryInit.autogen.cpp\n")
        w.write("// DO NOT EDIT BY HAND â€” generated from modules_presets.json\n\n")
        w.write('#include "RegistryInit.h"\n\n')
        for m in mods:
            fid = m["id"]
            w.write(f'extern "C" void register_{fid}(void) __attribute__((weak));\n')
        w.write("\n")
        w.write(f"void {args.ns}::init() {{\n")
        if not mods:
            w.write("  // No modules enabled; nothing to register.\n")
        else:
            for m in mods:
                fid = m["id"]
                w.write(f"  if (register_{fid}) register_{fid}();\n")
        w.write("}\n")

    print(f"Generated {args.out_cpp} with {len(mods)} module calls.")
    if args.out_h:
        print(f"Generated {args.out_h}")

if __name__ == '__main__':
    main()