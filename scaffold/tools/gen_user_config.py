#!/usr/bin/env python3
import os, sys, json, argparse, pathlib, shlex

# -------- Helpers --------

def normalize_rows(man):
    """Accept array, {boards:[...]}, or {FLAG:{...}} maps -> return list of rows."""
    if isinstance(man, list):
        return man
    if isinstance(man, dict):
        if "boards" in man and isinstance(man["boards"], list):
            return man["boards"]
        # flag-keyed map → convert to rows with 'flag' injected
        rows = []
        for k, v in man.items():
            if isinstance(v, dict):
                row = dict(v)
                row.setdefault("flag", k)
                rows.append(row)
        return rows
    return []

def pick_board(rows, flag=None, label=None):
    if flag:
        for r in rows:
            if r.get("flag") == flag:
                return r
    if label:
        for r in rows:
            if r.get("board_label") == label:
                return r
    return None

def load_json(path):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return json.load(f)
    except Exception:
        return None

def csv_to_list(s):
    if not s:
        return []
    return [x.strip() for x in s.split(",") if x.strip()]

def parse_pins_override(s):
    """
    Parse space-separated key=value pairs (values may be CSV).
    Example: "gps_pin=34,33 tft_pin=19,23,18,5,21,22 wifi_pin=19,23,18,5"
    Returns dict: { "gps_pin": ["34","33"], "tft_pin": [...], "wifi_pin": [...] }
    """
    if not s:
        return {}
    # use shlex to respect any quoting (rare but safe)
    parts = shlex.split(s)
    out = {}
    for part in parts:
        if "=" not in part:
            continue
        k, v = part.split("=", 1)
        k = k.strip()
        vals = [x.strip() for x in v.split(",") if x.strip()]
        if k:
            out[k] = vals
    return out

def coerce_boolish(v):
    if isinstance(v, bool):
        return v
    if v is None:
        return False
    s = str(v).strip().lower()
    return s in ("1","true","yes","y","on")

# -------- Main --------

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--boards-json", default="scaffold/configs/boards/boards_manifest.json")
    ap.add_argument("--defines-json", default="scaffold/configs/defines/build_defines.json")
    ap.add_argument("--modules-json", default="scaffold/configs/modules/modules_presets.json")
    ap.add_argument("--out", required=True)

    # Existing selectors
    ap.add_argument("--board-flag", default="")
    ap.add_argument("--board-label", default="")

    # NEW: workflow-driven overrides
    ap.add_argument("--profile", default="Auto (from board)")
    ap.add_argument("--modules-override", default="")   # CSV, only used if profile=Custom
    ap.add_argument("--pins-override", default="")      # space-separated k=v with CSV values
    ap.add_argument("--filesystem", default="")         # spiffs|littlefs (optional)

    args = ap.parse_args()

    # Load boards manifest
    boards_raw = load_json(args.boards_json)
    if boards_raw is None:
        print(f"::error ::Cannot read boards JSON: {args.boards_json}")
        sys.exit(1)

    boards = normalize_rows(boards_raw)
    board = pick_board(boards, args.board_flag, args.board_label)
    if not board:
        print(f"::error ::Board not found (flag={args.board_flag} label={args.board_label})")
        sys.exit(1)

    # Load defines & modules presets (both are optional)
    defines = load_json(args.defines_json)
    modules_presets = load_json(args.modules_json)

    # Begin composing config.h
    lines = []
    lines.append("// Autogenerated config.h")
    # Board flag
    bflag = (board.get("flag") or "").upper()
    if bflag:
        lines.append(f"#define BOARD_FLAG_{bflag} 1")

    # Filesystem & partition (with optional override from CLI)
    fs_from_board = (board.get("filesystem") or "spiffs").strip().lower()
    fs = (args.filesystem.strip().lower() or fs_from_board)
    if fs not in ("spiffs", "littlefs"):
        fs = "spiffs"
    part = board.get("partition") or "min_spiffs"
    addr = board.get("addr") or "0x1000"

    # Emit FS + partition + addr
    lines.append(f"#define FS_TYPE_{fs.upper()} 1")
    lines.append(f"#define PARTITION_SCHEME \"{part}\"")
    lines.append(f"#define FLASH_ADDR {addr}")

    # Display hint from board (non-authoritative; TFT header generator handles real wiring)
    disp = board.get("display") or {}
    if coerce_boolish(disp.get("enabled")):
        lines.append("#define DISPLAY_ENABLED 1")
        if disp.get("model"):
            model = str(disp["model"]).strip()
            if model:
                safe = "".join(c if c.isalnum() or c == '_' else '_' for c in model.upper())
                lines.append(f"#define DISPLAY_MODEL_{safe} 1")
    else:
        lines.append("#define DISPLAY_ENABLED 0")

    # Libraries hints (optional)
    libs = board.get("libs") or {}
    if libs.get("nimble_version"):
        lines.append(f"#define NIMBLE_VERSION \"{libs['nimble_version']}\"")
    ea = (libs.get("esp_async") or {})
    if ea.get("version"):
        lines.append(f"#define ESP_ASYNC_WEBSERVER_VERSION \"{ea['version']}\"")

    # Global defines list (build_defines.json)
    if isinstance(defines, list):
        for row in defines:
            flag = str(row.get("flag") or row.get("name") or "").strip()
            val  = row.get("value")
            if not flag:
                continue
            if isinstance(val, (int, float)) or (isinstance(val, str) and val.isdigit()):
                lines.append(f"#define {flag} {val}")
            elif isinstance(val, str) and val != "":
                lines.append(f"#define {flag} \"{val}\"")
            else:
                lines.append(f"#define {flag} 1")

    # -------- Modules resolution --------
    # Strategy:
    # 1) If profile == "Auto (from board)" → board.get("profile") or fallback "Standard"
    # 2) If profile == name (not Custom) → load modules set from modules_presets.json
    # 3) If profile == Custom → parse --modules-override CSV
    resolved_profile = (args.profile or "").strip()
    if resolved_profile.lower().startswith("auto"):
        resolved_profile = (board.get("profile") or "Standard")

    enabled_modules = set()

    def add_enabled(mod_name):
        if not mod_name:
            return
        safe = "".join(c if c.isalnum() or c == '_' else '_' for c in mod_name.strip().upper())
        if safe:
            enabled_modules.add(safe)

    if resolved_profile.lower() == "custom":
        for m in csv_to_list(args.modules_override):
            add_enabled(m)
    else:
        # Try to read from modules_presets.json
        # Support a few shapes:
        #  a) { "presets": { "Standard": ["WIFI","BLE",...], ... } }
        #  b) { "Standard": ["WIFI","BLE",...] }   (top-level mapping)
        #  c) [{ "profile":"Standard","module":"WIFI","enabled":true }, ...]
        preset_found = False
        if isinstance(modules_presets, dict):
            if "presets" in modules_presets and isinstance(modules_presets["presets"], dict):
                arr = modules_presets["presets"].get(resolved_profile)
                if isinstance(arr, list):
                    for m in arr:
                        add_enabled(str(m))
                    preset_found = True
            elif resolved_profile in modules_presets and isinstance(modules_presets[resolved_profile], list):
                for m in modules_presets[resolved_profile]:
                    add_enabled(str(m))
                preset_found = True
        if not preset_found and isinstance(modules_presets, list):
            # interpret as rows
            for row in modules_presets:
                prof = str(row.get("profile") or "").strip()
                if prof == resolved_profile:
                    mod = str(row.get("module") or row.get("name") or "").strip()
                    if mod and coerce_boolish(row.get("enabled", True)):
                        add_enabled(mod)

    # Emit module defines
    for mod in sorted(enabled_modules):
        lines.append(f"#define MODULE_{mod} 1")

    # -------- Pins override --------
    pins_map = parse_pins_override(args.pins_override)
    if pins_map:
        # Compact strings for debug/inspection
        for k, vals in pins_map.items():
            macro_key = "".join(c if c.isalnum() or c == '_' else '_' for c in k.upper())
            lines.append(f"#define PINS_{macro_key} \"{','.join(vals)}\"")
            # Also index them for code that expects individual macros
            if len(vals) == 1:
                lines.append(f"#define PIN_{macro_key} {vals[0]}")
            for idx, val in enumerate(vals, start=1):
                lines.append(f"#define PIN_{macro_key}_{idx} {val}")

    # -------- Finalize --------
    outp = pathlib.Path(args.out)
    outp.parent.mkdir(parents=True, exist_ok=True)
    outp.write_text("\n".join(lines) + "\n", encoding="utf-8")
    print(f"[OK] Wrote {outp}")
    # Useful echo for CI debugging
    print(f"[PROFILE] {resolved_profile}")
    if enabled_modules:
        print("[MODULES]", ", ".join(sorted(enabled_modules)))
    if pins_map:
        print("[PINS_OVERRIDE_KEYS]", ", ".join(sorted(pins_map.keys())))

if __name__ == "__main__":
    main()
